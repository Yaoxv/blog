<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ManageIQ Provider开发（一）：ManageIQ的安装]]></title>
    <url>%2F2019%2F01%2F04%2Fmanageiq-install%2F</url>
    <content type="text"><![CDATA[系统环境Ubuntu 16.04 64位 依赖包安装及配置12345678910111213141516171819202122232425262728# Git and componentssudo apt install git# Memcached for the session storesudo apt install memcached # PostgreSQL Database server and to build 'pg' Gemsudo apt install postgresql libpq-dev# For Nokogiri Gemsudo apt install libxml2-dev libxslt-dev patch # For sqlite3 Gemsudo apt install libsqlite-dev libsqlite3-dev # For unf Gemsudo apt install g++ # For Curbsudo apt install libcurl4-gnutls-dev # For rugged Gemsudo apt install cmakesudo apt install libgit2-dev pkg-config libtool# For puma &lt; 3.7.0sudo apt install libssl-dev 123456789101112131415161718192021222324252627282930313233# Install Node.js(version &gt;= 8.9.0)wget https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gztar -xzvf node-v10.15.0.tar.gzcd ./node-v10.15.0./configuresudo make &amp;&amp; make install# Enable Memcachedsudo systemctl enable memcachedsudo systemctl start memcached# Configure PostgreSQLsudo grep -q '^local\s' /etc/postgresql/9.5/main/pg_hba.conf || echo "local all all trust" | sudo tee -a /etc/postgresql/9.5/main/pg_hba.confsudo sed -i.bak 's/\(^local\s*\w*\s*\w*\s*\)\(peer$\)/\1trust/' /etc/postgresql/9.5/main/pg_hba.confsudo systemctl restart postgresqlsudo su postgres -c "psql -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\""# Install Ruby(version &gt;= 2.3.1)wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.5.tar.gztar -xzvf ruby-2.4.5.tar.gzcd ./ruby-2.4.5./configuresudo make &amp;&amp; make install# Install the Bower package managersudo npm install -g bower# Install the Yarn package managersudo npm install -g yarn# Install the Gulp and Webpack build systemsudo npm install -g gulp-clisudo npm install -g webpack ManageIQ安装当前版本 Gaprindashvili-7 ManageIQ在Github上master分支不是稳定版本 123456# Clone the Codegit clone -b gaprindashvili-7 https://github.com/ManageIQ/manageiq.git# Install ManageIQcd ./manageiqbin/setup ManageIQ的依赖安装，配置，数据库初始化都将执行，所以安装过程较长。国内网络原因可能会造成安装失败，建议挂梯子执行安装，或修改npm、yarn的源。 启动ManageIQ1bundle exec rake evm:start 参考文档ManageIQ安装官方文档]]></content>
      <categories>
        <category>ManageIQ</category>
      </categories>
      <tags>
        <tag>manageiq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大话设计模式》笔记]]></title>
    <url>%2F2018%2F12%2F10%2Ftalking-about-design-pattern%2F</url>
    <content type="text"><![CDATA[简单工厂模式 工厂根据传入参数判断，实例化合适的对象，通过多态返回父类的方式 策略模式 定义了算法家族，分别封装起来，使算法的变化不会影响使用算法的客户 装饰模式 为已有功能动态地添加更多功能 代理模式 为其他对象提供一种代理以控制这个对象的访问 工厂方法模式 定义一个用于创建对象的接口，让子类决定实例化哪一类。使一个类的实例化延迟到其子类 原型模式 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 模板方法模式 定义一个操作中的算法的骨架，将一些步骤延迟到子类中 外观模式 为子系统中的一组接口提供统一的界面 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 观察者模式/发布-订阅模式 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，会通知所有观察者对象，是他们能够自动更新自己 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类 状态模式 解决一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，简化复杂的判断逻辑]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>reading notes</tag>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Docker技术入门与实战》笔记]]></title>
    <url>%2F2018%2F12%2F04%2Fdocker-practice%2F</url>
    <content type="text"><![CDATA[Docker 安装与配置 系统 : Ubuntu 18 安装1sudo apt install docker.io 配置 以普通用户启动docker 官方文档对于非root用户启动docker的说明 The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The Docker daemon always runs as the root user. If you don’t want to preface the docker command with sudo, create a Unix group called docker and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group. 1234567891011121314# 创建docker组sudo groupadd docker# 添加当前用户到docker组sudo usermod -aG docker $username# 注销并重新登陆# 在虚拟机上可能需要重启# 重启docker服务sudo systemctl restart docker# 如果还存在/var/run/docker.sock的权限问题，尝试一下命令sudo chmod a+rw /var/run/docker.sock 修改默认镜像仓库为阿里云 https://cr.console.aliyun.com/#/accelerator 查看个人镜像地址并根据操作文档修改 删除镜像对于存在容器依赖的镜像，需要先删除该镜像的所有容器，再删除镜像 不要使用 -f 来强制删除 进入容器 attach --detach-keys[=[]]设置退出attach的快捷键，默认为CTRL-p + CTRL-q 多个窗口使用attach命令进入同一个容器时，所有窗口会同步显示。一个窗口因为某个命令阻塞时，所有窗口都无法进行其他操作了 exec 1docker exec -it $contianer_id /bin/bash nsenter 12345# 获取容器的PIDPID=$(docker inspect --format &#123;&#123;.State.Pid&#125;&#125; &lt;container_name_or_ID&gt;)# 进入容器nsenter --target $PID --mount --uts --ipc --net --pid 数据管理数据卷 Date Volumes容器内数据直接映射到本地主机环境 12345# 挂在主机目录/src/webapp到容器的/opt/webapp为数据卷docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py# 挂载的数据卷的默认权限为rw，可以指定为rodocker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py 数据卷容器 Date Volume Containers多个容器间共享数据 1234567891011121314151617# 创建数据卷容器dbdata，挂载到数据卷容器目录/dbdatadocker run -it -v /dbdata --name dbdata ubuntu# 其他容器挂载dbdatadocker run -it --volumes-from dbdata --name db ubuntu# 在任意容器中改变dbdata目录下的文件，所有容器都能看到改变# 备份# 利用ubuntu镜像创建容器worker，并挂载dbdata数据卷，挂载本地当前目录到worker的/backup目录，容器启动后打包/dbdata目录为tardocker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata# 恢复# 1.创建另一个数据卷容器# 2.创建另一个容器把备份解压到1中的数据卷容器docker run -v /dbdata --name dbdata2 ubuntu /bin/bashdocker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar 挂载的数据卷容器不需要保持在运行状态 命名空间命名空间保证了各个容器之间不会相互影响。 进程命名空间 docker进程为父进程，容器的进程为子进程 网络命名空间 Docker采用虚拟网络设备(Virtual Network Device)将不同命名空间的网络设备连接到一起 默认情况下，容器中的虚拟网卡将同本地主机的docker0网桥连接在一起 IPC命名空间 同一个IPC命名空间内的进程可以进行交互，不同空间的进程无法交互 挂载命名空间 UTS命名空间 用户命名空间]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《MySQL必知必会》笔记]]></title>
    <url>%2F2018%2F12%2F03%2Fmysql-crash-course%2F</url>
    <content type="text"><![CDATA[计算次序 AND的计算次序高于OR的计算次序 vend_id = 1003 与 prod_price &gt;= 10 先计算，之后再和 vend_id = 1002 进行计算，所以结果为 id = 1002的商品和 id = 1003 且 price &gt;= 10 的商品。 查询区分大小写建表时设置字段区分大小写1234CREATE TABLE t ( a VARCHAR(32) BINARY, b VARCHAR(32)); VARCHAR BINARY以字节存储，大小写敏感 VARCHAR以字符存储，大小写不敏感 1234CREATE TABLE t ( a varchar(32) COLLATE utf8_bin DEFAULT NULL, b varchar(32) DEFAULT NULL) utf8_bin 将字符串以字节存储，大小写敏感 utf8_genera_ci 大小写不敏感 , ci = case insensitive utf8_genera_cs 大小写敏感 , cs = case sensitive 查询时指定大小写敏感1select * from t where a = binary "xxx"; 别名列别名在MySQL中，可以使用ORDER BY，GROUP BY和HAVING子句中的列别名来引用该列 123456789101112131415#将姓和名拼接为全名，并以全名排序select concat(first_name,' ',last_name) as full_name from tb_user order by full_name;#单价*天数 = 总价，总价大于100select order_id,price*day as total from tb_order having total &gt; 100;#选择消费总额大于100的用户select username,sum(price*day) total from tb_order group by username having total &gt; 100; 表别名123select username,price from tb_user as u,tb_order as u where u.id = o.u_id 表别名只在查询过程中使用，不返回给客户端 WHERE和HAVING的差别 WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组 左联结和右联结LEFT OUTER JOIN 表示从左边的表中选择所有行 RIGHT OUTER JOIN 表示从右边的表中选择所有行 1234# 检索所有用户的用户名和订单信息，包含没有下订单的用户select tb_user.username,tb_order.*from tb_user left outer join tb_orderon tb_user.id = tb_order.u_id; INSERT性能单条INSERT语句处理多个插入比多条INSERT语句快 TRUNCATE删除表并重新创建 1TRUNCATE TABLE table_name 重置自增id 使用truncate：truncate table； 使用修改标识：dbcc checkident (‘table_name’ , reseed, new_reseed_value) ;说明：new_reseed_value是设置的当前标识，下次插入则从new_reseed_value+1开始。如果new_reseed_value小于表中当前标识的值，有可能会产生重复key，会产生 2627 号错误信息。用处：此方法不会清空已有数据。适用于大量删除后修改新的标识，但不能比当前表中最大值小。 使用修改表的方法：alter table tablename auto_increment=new 说明：此方法和上面的二方法类似。也不会清空数据，有可能会出现重复key的可能，所以此方法也只适用于清空表之后重置自增id或者大量删除后修改自增id。 引擎类型 MyISAM 性能极高 支持全文搜索 不支持事务处理 MEMORY 功能与MyISAM相同 数据存储在内存，速度快，适合临时表 InnoDB 可靠的事务处理 不支持全文搜索 外键不能跨引擎 存储过程 优点 减少网络传输耗时 适合业务需求稳定的项目 缺点 消耗数据库资源 不适用需求多变的项目 不便于跨数据库间的移植]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>reading notes</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tuleap的postfix邮件设置]]></title>
    <url>%2F2018%2F11%2F22%2Ftuleap-postfix-config%2F</url>
    <content type="text"><![CDATA[Tuleap使用postfix作为邮件转发工具，自行搭建邮件服务器比较麻烦，我们可以使用postfix + smtp实现发送邮件的功能，这里以QQ邮箱为例，Gmail、163等同理。 配置main.cf123456789101112131415161718192021$ vim /etc/postfix/main.cf#修改inet_interfaces = localhostinet_interfaces = all#在文件最后添加myhostname = tuleap.example.commyorigin = $mydomainrelayhost = [smtp.qq.com]:587# Enable SASL authenticationsmtp_sasl_auth_enable = yes# Disallow methods that allow anonymous authenticationsmtp_sasl_security_options = noanonymous# Location of sasl_passwdsmtp_sasl_password_maps = hash:/etc/postfix/sasl/sasl_passwd# Enable STARTTLS encryptionsmtp_tls_security_level = encrypt# Location of CA certificatessmtp_tls_CAfile = /etc/postfix/server.pemsmtp_generic_maps = hash:/etc/postfix/generic 配置QQ邮箱SMTP账户生成QQ邮箱smtp服务token 创建账户配置文件 1234$ mkdir /etc/postfix/sasl$ vim /etc/postfix/sasl/sasl_passwd[smtp.qq.com]:587 xxxxxxxx@qq.com:token 创建hash加密文件sasl_passwd.db 1$ postmap /etc/postfix/sasl/sasl_passwd 创建CA证书12345678$ cd /etc/ssl/certs/$ vim Makefile# 修改证书有效期 DAYS 为合适的时间DAYS=xxx$ make server.pem$ mv server.pem /etc/postfix 添加账号映射Tuleap的邮件发信人为noreply@tuleap.example.com QQ邮箱SMTP的发件人为sasl_passwd中设置的账号 账号不同时，QQ邮箱会返回报错mail from address must be same as authorization user 1234$ vim /etc/postfix/generic#在文件最后添加noreply@tuleap.example.com xxxxx@qq.com 测试postfix重启postfix 1$ service postfix restart 登陆tuleap，测试邮件发送功能，如果收不到邮件，查看maillog发送日志排查错误 1$ cat /var/log/maillog]]></content>
      <categories>
        <category>Tuleap</category>
      </categories>
      <tags>
        <tag>tuleap</tag>
        <tag>postfix</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tuleap的安装]]></title>
    <url>%2F2018%2F11%2F21%2Ftuleap-install%2F</url>
    <content type="text"><![CDATA[系统CentOS 7 关闭SElinux修改selinux配置文件 12345678910111213$ vim /etc/selinux/config# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 重启服务器 1$ shutdown -r now 验证selinux已关闭 123$ sestatusSELinux status: disabled 安装安装EPEL12$ yum install -y epel-release$ yum install -y centos-release-scl 安装 remi-safe 库1$ yum install -y https://rpms.remirepo.net/enterprise/remi-release-7.rpm 安装 Tuleap 库12345678$ vim /etc/yum.repos.d/Tuleap.repo[Tuleap]name=Tuleapbaseurl=https://ci.tuleap.net/yum/tuleap/rhel/7/dev/$basearchenabled=1gpgcheck=1gpgkey=https://ci.tuleap.net/yum/tuleap/gpg.key 安装 Tuleap12345678$ yum install -y \ rh-mysql57-mysql-server \ tuleap-plugin-agiledashboard \ tuleap-plugin-graphontrackers \ tuleap-theme-burningparrot \ tuleap-theme-flamingparrot \ tuleap-plugin-git \ tuleap-plugin-pullrequest 更多插件安装详见官方插件列表 配置数据库1234$ vim /etc/opt/rh/rh-mysql57/my.cnf.d/rh-mysql57-mysql-server.cnf#在[mysqld]下添加sql-mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 设置mysql开机自启 1$ systemctl enable rh-mysql57-mysqld 启动mysql 1$ systemctl start rh-mysql57-mysqld 设置mysql密码 1$ scl enable rh-mysql57 "mysqladmin -u root password" 启动 请勿重复执行该命令 12345/usr/share/tuleap/tools/setup.el7.sh \ --configure \ --server-name=tuleap.example.com \ --mysql-server=localhost \ --mysql-password=XXXXX server-name : 本地测试时设为localhost 确保防火墙开放所需端口 Web (TCP/80 &amp; TCP/443) SSH (git, admin): TCP/22 首次登陆登陆Tuleap (例如: tuleap.example.com) 默认的管理员密码在 /root/.tuleap_passwd 中可以找到]]></content>
      <categories>
        <category>Tuleap</category>
      </categories>
      <tags>
        <tag>tuleap</tag>
        <tag>php</tag>
        <tag>agile management</tag>
      </tags>
  </entry>
</search>
